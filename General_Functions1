package Utilities;


import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.stream.Stream;

import org.apache.commons.io.FileUtils;
import org.apache.poi.ss.usermodel.BorderStyle;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.CellStyle;
import org.apache.poi.ss.usermodel.DataFormatter;
import org.apache.poi.ss.usermodel.HorizontalAlignment;
import org.apache.poi.ss.usermodel.IndexedColors;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xssf.streaming.SXSSFSheet;
import org.apache.poi.xssf.streaming.SXSSFWorkbook;
import org.apache.poi.xssf.usermodel.XSSFCell;
import org.apache.poi.xssf.usermodel.XSSFCellStyle;
import org.apache.poi.xssf.usermodel.XSSFFont;
import org.apache.poi.xssf.usermodel.XSSFRow;
import org.apache.poi.xssf.usermodel.XSSFSheet;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;

import com.google.common.base.Strings;
import com.monitorjbl.xlsx.StreamingReader;

public class General_Functions1 {
	
	public   String driverName_Hive = "org.apache.hive.jdbc.HiveDriver";
	public   String driverName_Sql = "com.microsoft.sqlserver.jdbc.SQLServerDriver";
	public  String driverName_DB2="com.ibm.db2.jcc.DB2Driver";
	public  String driverName_Nete="org.netezza.Driver";
    public   Connection con;
    public   Statement stmt;
    public ResultSet res;
    public String Src_DB,Src_Query,Src_Username,Src_Password,Src_Server_name,Src_Port,Src_DB_Name,Src_Host;
	public  String Src_EOR;
	public  String Src_Symbol;
	public  String Src_Col_Name;
    public String Tgt_DB,Tgt_Query,Tgt_Username,Tgt_Password,Tgt_Server_name,Tgt_Port,Tgt_DB_Name,Tgt_Host;
	public  String Tgt_EOR;
	public  String Tgt_Symbol;
	public String Tgt_Col_Name;
    public  String Input_File_Path_Source;
	public  String Input_File_Path_Target;
	public  String Result_File;
	public String Key_Column;
	public  Cell cell_final;
	public  String Src_FTP_file,Tgt_FTP_file;
	public  String Src_FTP_bat,Tgt_FTP_bat;
	public String Src_Copy_book,Tgt_Copy_book;
	public  String Src_File_Name,Tgt_File_Name;
	public  String Result_Folder;
	public  String Src_File_mainframe_path,Tgt_File_mainframe_path;
	
 
	
	public   HashSet<String> Src_data = new HashSet<String>(); 
	public   HashSet<String> Tgt_data = new HashSet<String>(); 
	public   HashSet<String> Src_duplicate = new HashSet<String>(); 
	public   HashSet<String> Tgt_duplicate = new HashSet<String>(); 
	public   HashSet<String> Temp_Src_data; 
	public   HashSet<String> Temp_Tgt_data; 
	public   HashMap<String, String> Src_Map =new HashMap<String, String>();
	public   HashMap<String, String> Tgt_Map =new HashMap<String, String>();
	
	public   HashMap<Integer, Long> Column_Mismatch =new HashMap<Integer, Long>();
	 
	public   HashMap<Integer, String> Table_column =new HashMap<Integer, String>();
	public   HashMap<Integer, String> Table_column_key =new HashMap<Integer, String>();
   
    public  boolean Non_Primary=true;
    
    public  long Total_Src_Count,Total_Tgt_Count,Total_Src_Count_no_dup,Total_Tgt_Count_no_dup,Src_duplicate_count,Tgt_duplicate_count;
  
    public  String Source_Missing="Source Missing";
    public  String Target_Missing="Target Missing";
    public  String Count_Report="Count Summary";
    public  String Source_Duplicate="Source Duplicate";
    public  String Target_Duplicate="Target Duplicate";
  
    public  String Data_Mismatch="Data Mismatch";
    public  String Summary="Summary";
    public  boolean Source_Missing_Flag=false;
    public  boolean Target_Missing_Flag=false;
    
    public  boolean Source_Duplicate_Flag=false;
    public  boolean Target_Duplicate_Flag=false;
    public  boolean Data_Mismatch_Flag=false;
    public  boolean Count_Mismatch_Flag=false;
    public  String[] Src_Column_Name,Tgt_Column_Name;
    public  int Src_Column_Count,Tgt_Column_Count;
    public  int Record_Count,Src_missing_count,Tgt_missing_count,Data_mismatch_count;
    public  int[] Keyvalue_Column;
    
    public   Row row_final;
	public  XSSFCellStyle lock_Final;
    
   
    
  
    
     public void setvalue_Src_Hive(String Src_DB1,String Src_Query1,String Src_Username1,String Src_Password1) throws IOException {
    	
    	Src_DB=Src_DB1;
    	Src_Query=Src_Query1;
    	Src_Username=Src_Username1;
    	Src_Password=Src_Password1;
    	
    	
    }
     
     public void setvalue_Src_Sql_Server(String Src_DB1,String Src_Query1,String Src_Username1,String Src_Password1,String Server1,String DBname) throws IOException {
     	
     	Src_DB=Src_DB1;
     	Src_Query=Src_Query1;
     	Src_Username=Src_Username1;
     	Src_Password=Src_Password1;
     	Src_Server_name=Server1;
    	Src_DB_Name=DBname;
     	
     	
     }
     
     public void setvalue_Src_DB2(String Src_DB1,String Src_Query1,String Src_Username1,String Src_Password1,String DBname,String port,String host) throws IOException {
      	
      	Src_DB=Src_DB1;
      	Src_Query=Src_Query1;
      	Src_Username=Src_Username1;
      	Src_Password=Src_Password1;
      	Src_DB_Name=DBname;
      	Src_Port=port;
      	Src_Host=host;
      	
      	
      }
     
     public void setvalue_Src_Netezza(String Src_DB1,String Src_Query1,String Src_Username1,String Src_Password1,String DBname,String server) throws IOException {
       	
       	Src_DB=Src_DB1;
       	Src_Query=Src_Query1;
       	Src_Username=Src_Username1;
       	Src_Password=Src_Password1;
       	Src_DB_Name=DBname;
       	Src_Server_name=server;
       	
       	
       }
     
     public void setvalue_Src_Excel(String Src_DB1,String input_file) throws IOException {
       	
       	Src_DB=Src_DB1;
       	Input_File_Path_Source=input_file;
       	
       
       	
       }
     
     public void setvalue_Src_CSV(String Src_DB1,String input_file,String eor,String Symbol,String Col_name) throws IOException {
        	
        	Src_DB=Src_DB1;
        	Input_File_Path_Source=input_file;
        	Src_EOR=eor;
        	Src_Symbol=Symbol;
        	Src_Col_Name=Col_name;
        	
        
        	
        }
     
     public void setvalue_Src_Mainframe(String Src_DB1,String user,String pwd,String host,String f3,String FF,String f1,String f2,String f4,String f5) throws IOException {
     	
     	Src_DB=Src_DB1;
     	Src_Username=user;
       	Src_Password=pwd;
       	Src_Host=host;
       	Src_File_Name=f3;
        Src_FTP_file=FF;
    	Src_FTP_bat=f1;
    	Src_Copy_book=f2;
    	Result_Folder=f4;
    	Input_File_Path_Source=f5;
    	Src_File_mainframe_path=Result_Folder+"'"+Src_File_Name+"'";
    	
    	PrintWriter writer = new PrintWriter(Src_FTP_file, "UTF-8");
	    writer.println(Src_Username);
	    writer.println(Src_Password);
	    writer.println("get '"+Src_File_Name+"'");
	    writer.println("quit");
	    writer.close();
	    
	    PrintWriter writer1 = new PrintWriter(Src_FTP_bat, "UTF-8");
	    writer1.println("cd\\");
	    writer1.println("C:");
	    writer1.println("cd "+Result_Folder);
	    writer1.println("ftp -s:"+Src_FTP_file+" "+Src_Host);
	    writer1.println("exit(0)");
	    writer1.close();
	    
	    Runtime runtime = Runtime.getRuntime();
		
		Process p1 = runtime.exec("cmd /c start "+Src_FTP_bat);
		
     	
     }
     
     
     public void setvalue_Tgt_Mainframe(String Src_DB1,String user,String pwd,String host,String f3,String FF,String f1,String f2,String f4,String f5) throws IOException {
      	
      	Tgt_DB=Src_DB1;
      	Tgt_Username=user;
        	Tgt_Password=pwd;
        	Tgt_Host=host;
        	Tgt_File_Name=f3;
         Tgt_FTP_file=FF;
     	Tgt_FTP_bat=f1;
     	Tgt_Copy_book=f2;
     	Result_Folder=f4;
     	Input_File_Path_Target=f5;
     	Tgt_File_mainframe_path=Result_Folder+"'"+Tgt_File_Name+"'";
     	
     	PrintWriter writer = new PrintWriter(Src_FTP_file, "UTF-8");
 	    writer.println(Src_Username);
 	    writer.println(Src_Password);
 	    writer.println("get '"+Tgt_File_Name+"'");
 	    writer.println("quit");
 	    writer.close();
 	    
 	    PrintWriter writer1 = new PrintWriter(Tgt_FTP_bat, "UTF-8");
 	    writer1.println("cd\\");
 	    writer1.println("C:");
 	    writer1.println("cd "+Result_Folder);
 	    writer1.println("ftp -s:"+Tgt_FTP_file+" "+Tgt_Host);
 	    writer1.println("exit(0)");
 	    writer1.close();
 	    
 	    Runtime runtime = Runtime.getRuntime();
 		
 		Process p1 = runtime.exec("cmd /c start "+Tgt_FTP_bat);
 		
      	
      }
      
     
     public void setvalue_Tgt_CSV(String Src_DB1,String input_file,String eor,String Symbol,String Col_name) throws IOException {
     	
     	Tgt_DB=Src_DB1;
     	Input_File_Path_Target=input_file;
     	Tgt_EOR=eor;
     	Tgt_Symbol=Symbol;
     	Tgt_Col_Name=Col_name;
     	
     
     	
     }
     
     public void setvalue_Tgt_Hive(String Src_DB1,String Src_Query1,String Src_Username1,String Src_Password1) throws IOException {
     	
     	Tgt_DB=Src_DB1;
     	Tgt_Query=Src_Query1;
     	Tgt_Username=Src_Username1;
     	Tgt_Password=Src_Password1;
     	
     	
     }
      
      public void setvalue_Tgt_Sql_Server(String Src_DB1,String Src_Query1,String Src_Username1,String Src_Password1,String Server1,String DBname) throws IOException {
      	
      	Tgt_DB=Src_DB1;
      	Tgt_Query=Src_Query1;
      	Tgt_Username=Src_Username1;
      	Tgt_Password=Src_Password1;
      	Tgt_Server_name=Server1;
    	Tgt_DB_Name=DBname;
      
      	
      }
      
      public void setvalue_Tgt_DB2(String Src_DB1,String Src_Query1,String Src_Username1,String Src_Password1,String DBname,String port,String host) throws IOException {
       	
       	Tgt_DB=Src_DB1;
       	Tgt_Query=Src_Query1;
       	Tgt_Username=Src_Username1;
       	Tgt_Password=Src_Password1;
       	Tgt_DB_Name=DBname;
       	Tgt_Port=port;
    	Tgt_Host=host;
      
       	
       }
      
      public void setvalue_Tgt_Netezza(String Src_DB1,String Src_Query1,String Src_Username1,String Src_Password1,String DBname,String server) throws IOException {
         	
         	Tgt_DB=Src_DB1;
         	Tgt_Query=Src_Query1;
         	Tgt_Username=Src_Username1;
         	Tgt_Password=Src_Password1;
         	Tgt_DB_Name=DBname;
        	Tgt_Server_name=server;
        
         	
         }
      
      public void setvalue_Tgt_Excel(String Src_DB1,String input_file) throws IOException {
        	
        	Tgt_DB=Src_DB1;
        	Input_File_Path_Target=input_file;
        	
       	
        }
      
      public void set_Key_Value(String key,String Result_File1) throws IOException {
    	  Result_File=Result_File1;
    	  Key_Column=key;
      	  Key_Value_Split();
      	  Create_workbook_Sheets();
      	
      	
      }
      
      public void Source_caller() throws ClassNotFoundException, SQLException, IOException {
      	Source_query_Exe();
      	
      	
      }
      
      public void Source_caller_Excel() throws ClassNotFoundException, SQLException, IOException {
    	  Source_Excel_Exe();
      	
      }
      
      public void Target_caller() throws ClassNotFoundException, SQLException, IOException {
    	  Target_query_Exe();
        	
        	
        }
        
        public void Target_caller_Excel() throws ClassNotFoundException, SQLException, IOException {
      	  Target_Excel_Exe();
        	
        }
        
        public void Common_caller() throws ClassNotFoundException, SQLException, IOException {
        	Missing_Record();
        	Data_Validation();
        	Count_Validation();
        	Summary_sheet();
          	
          	
          }
        
        

    
    public void Source_query_Exe() throws SQLException, ClassNotFoundException, IOException {
    	
    	System.out.println("Source Query Begin");
    	long startTime = System.currentTimeMillis();
    	
    	if(Src_DB.equalsIgnoreCase("Hive")) {
    	
    	Hive_HDBC(Src_Username,Src_Password);
    	}

    	if(Src_DB.equalsIgnoreCase("SQL Server")) {
    	
    		SQL_Server(Src_Server_name,Src_DB_Name);
    	}
    	
    	if(Src_DB.equalsIgnoreCase("DB2")) {
        	
    		DB2_jDBC(Src_Username,Src_Password,Src_DB_Name,Src_Port,Src_Host);
    	}
    	
          if(Src_DB.equalsIgnoreCase("Netezza")) {
        	
    		Netezza(Src_Username,Src_Password,Src_DB_Name,Src_Server_name);
        	}
    	
    	 res= stmt.executeQuery(Src_Query);
    	 ResultSetMetaData rsmd=res.getMetaData();
    	 Src_Column_Name=new String[rsmd.getColumnCount()];
    	 Src_Column_Count=rsmd.getColumnCount();
    	 
    	 if(Src_Column_Count==Keyvalue_Column.length) {
    		 Non_Primary=false; 
    	 }
    	 
    	 int gg=0;
    	 int jj=0;
		
		 for(int i=0;i<rsmd.getColumnCount();i++){
				
			 if(i==0){
				 
				 Src_Column_Name[i]=rsmd.getColumnName(i+1).trim();
			 }
			 else{
				
				
				 Src_Column_Name[i]=rsmd.getColumnName(i+1).trim();
			 }
			 
			if(!(Key_Column_identifier(i))) {
				 gg++;
				 Column_Mismatch.put(gg, (long)0);
				
				 Table_column.put(gg,rsmd.getColumnName(i+1).trim());
			 }
			else {
				jj++;
				
				Table_column_key.put(jj,rsmd.getColumnName(i+1).trim());
				
			}
				
			}
		 
		 long Src_count=0;
		 while(res.next())
			{
			 
			 Src_count++;
			 
			
			 String key_val="";
			
             for(int k=0;k<Src_Column_Count;k++){
				 
					 String v=res.getString(k+1); 
					 if(k==0) {
						
						 if (res.wasNull()) {
							  key_val=key_val+"";
						  }
						  else {
							  key_val=key_val+v.trim();
						  }
						 
					 }
					 else {
						 
						 if (res.wasNull()) {
							  key_val=key_val+" | "+"";
						  }
						  else {
							  key_val=key_val+" | "+v.trim();
						  }
						 
					 }
					
					 
				 }
             
             
			   int temp=Src_data.size();
				 Src_data.add(key_val);
				 if(temp==Src_data.size()) {
					 Src_duplicate.add(key_val);
				 }
			 
			 
			 
			} 
		 DB_Close();
		 System.out.println("Source Query End");
		 
		 Total_Src_Count=Src_count;
		 Total_Src_Count_no_dup=Src_data.size();
		 Src_duplicate_count=Src_duplicate.size();
		 
		 Source_dup();
		 Src_duplicate.clear();
		 System.out.println("Source completed");
		 long stopTime = System.currentTimeMillis();
		 long elapsedTime = stopTime - startTime;
		 System.out.println("Source time taken :"+elapsedTime/1000+ " Seconds");

    }
    
    
    
    
    
public void Target_query_Exe() throws SQLException, ClassNotFoundException, IOException {
	System.out.println("Target Started");
	long startTime = System.currentTimeMillis();	
      if(Tgt_DB.equalsIgnoreCase("Hive")) {
    	
    	Hive_HDBC(Tgt_Username,Tgt_Password);
    	}

    	if(Tgt_DB.equalsIgnoreCase("SQL Server")) {
    	
    		SQL_Server(Tgt_Server_name,Tgt_DB_Name);
    	}
    	
    	if(Tgt_DB.equalsIgnoreCase("DB2")) {
        	
    		DB2_jDBC(Tgt_Username,Tgt_Password,Tgt_DB_Name,Tgt_Port,Tgt_Host);
    	}
         if(Tgt_DB.equalsIgnoreCase("Netezza")) {
        	
    		Netezza(Tgt_Username,Tgt_Password,Tgt_DB_Name,Tgt_Server_name);
        	}
    	res= stmt.executeQuery(Tgt_Query);
    	
    	 ResultSetMetaData rsmd=res.getMetaData();
    	 Tgt_Column_Name=new String[rsmd.getColumnCount()];
    	 Tgt_Column_Count=rsmd.getColumnCount();
		
		 for(int i=0;i<rsmd.getColumnCount();i++){
				
			 if(i==0){
				
			
			
				 Tgt_Column_Name[i]=rsmd.getColumnName(i+1);
			 }
			 else{
				
				
				 Tgt_Column_Name[i]=rsmd.getColumnName(i+1);
			 }
				
			}
		 
		 long Tgt_count=0;
		 while(res.next())
			{
			 
			 Tgt_count++;
			 

			 String key_val="";
			
             for(int k=0;k<Tgt_Column_Count;k++){
				 
					 String v=res.getString(k+1); 
					 if(k==0) {
						
						 if (res.wasNull()) {
							  key_val=key_val+"";
						  }
						  else {
							  key_val=key_val+v.trim();
						  }
						 
					 }
					 else {
						 
						 if (res.wasNull()) {
							  key_val=key_val+" | "+"";
						  }
						  else {
							  key_val=key_val+" | "+v.trim();
						  }
						 
					 }
					
					 
				 }
             
             
			   int temp=Tgt_data.size();
			   //System.out.println(key_val);
			   Tgt_data.add(key_val);
				 if(temp==Tgt_data.size()) {
					 Tgt_duplicate.add(key_val);
				 }
			 
			 
			 
			} 
		 DB_Close();
		 System.out.println("Target Query End");
		 Total_Tgt_Count=Tgt_count;
		 Total_Tgt_Count_no_dup=Tgt_data.size();
		 Tgt_duplicate_count=Tgt_duplicate.size();
		 Target_dup();
		
		 Tgt_duplicate.clear();
		 System.out.println("Target completed");
		
		 long stopTime = System.currentTimeMillis();
		 long elapsedTime = stopTime - startTime;
		 System.out.println("Target time taken :"+elapsedTime/1000+ " Seconds");
    	
    }

  public boolean Key_Column_identifier(int i) {
	
	 boolean test = false; 
    for (int element : Keyvalue_Column) { 
        if (element == i) { 
            test = true; 
            break; 
        } 
    }
    
    if(test) {
   	 return true;
   	
    }
    else
   	 return false;
	
}
  
  
  public  void Source_dup() throws IOException{
	  long startTime = System.currentTimeMillis();	
	  System.out.println("Source duplicate begin");
	  ArrayList<String> record = new ArrayList<String>(Src_duplicate);
	
	  int h=0;
	  Header_Duplicate(Result_File,Source_Duplicate,Src_Column_Name);
	
	  
	  if(record.size()>0) {
		  Source_Duplicate_Flag=true;
	  Duplicate_Bulk_Writer(Result_File,Source_Duplicate,record);
	  }
	 // System.out.println("Source Duplicate end");
	  record.clear();
	
	  long stopTime = System.currentTimeMillis();
		 long elapsedTime = stopTime - startTime;
		 System.out.println("Source Duplicate time Taken:"+elapsedTime/1000+ " Seconds");
	  
  }
  
public void Target_dup() throws IOException{
	 long startTime = System.currentTimeMillis();	
	 System.out.println("Target Duplicate begin");
	  ArrayList<String> record = new ArrayList<String>(Tgt_duplicate);
	 
	  int h=0;
	  
	  Header_Duplicate(Result_File,Target_Duplicate,Tgt_Column_Name);
	  
	  
	 
	  
	  if(record.size()>0) {
		  Target_Duplicate_Flag=true;
	   Duplicate_Bulk_Writer(Result_File,Target_Duplicate,record);
	  }
		
		 record.clear();
		
		  long stopTime = System.currentTimeMillis();
			 long elapsedTime = stopTime - startTime;
			 System.out.println("Target Duplicate time Taken:"+elapsedTime/1000+ " Seconds");
		  
  }




public  void Count_Validation() throws IOException{
	 long startTime = System.currentTimeMillis();	
	  
	System.out.println("Count validation begin");
    
    if(Total_Src_Count==Total_Tgt_Count){
		Count_Mismatch_Flag=false;
	}
	else{
		Count_Mismatch_Flag=true;
	}
    
    Count_Write(Result_File,Count_Report);
  
  
	System.out.println("count validation end");
	 long stopTime = System.currentTimeMillis();
	 long elapsedTime = stopTime - startTime;
	 System.out.println("Target Duplicate time Taken:"+elapsedTime/1000+ " Seconds");
}

public void Missing_Record() throws IOException{
	 long startTime = System.currentTimeMillis();	
	
	System.out.println("Missing record begin");
	int row=0;
	ArrayList<String> record_Target = new ArrayList<String>();
	ArrayList<String> record_Source = new ArrayList<String>();
	
	ArrayList<String> Dele_Src = new ArrayList<String>();
	ArrayList<String> Dele_Tgt = new ArrayList<String>();
	
	Header_Missing_tgt(Result_File,Target_Missing);
	Header_Missing_Src(Result_File,Source_Missing);
	
   
   
    
    Temp_Src_data = new  HashSet<String>(Src_data);
    Temp_Tgt_data = new  HashSet<String>(Tgt_data);
    
    System.out.println(Temp_Src_data.size());
    System.out.println(Temp_Tgt_data.size());
  
    Temp_Src_data.removeAll(Tgt_data);
    Temp_Tgt_data.removeAll(Src_data);
    
    
    System.out.println("aaaaa :"+Temp_Src_data.size());
    System.out.println("aaaaa :"+Temp_Tgt_data.size());
  
    
    Src_data.clear();
	Tgt_data.clear();
	
	spliter1();
	

    Temp_Src_data.clear();
    Temp_Tgt_data.clear();
    
    int count=0;
    int count1=0;
    		
    
    for (String key : Src_Map.keySet())  
    { 
         
    	if(!(Tgt_Map.containsKey(key))){
			  Source_Missing_Flag=true;
			  
			  count++;
			  Dele_Src.add(key);
			 
			  if(count<=200) {
			  record_Source.add("Present in Source But not in Target | "+key);
    	      }  
			 
		  }
    	
    } 
    
    for (String key : Tgt_Map.keySet())  
    { 
         
    	if(!(Src_Map.containsKey(key))){
			  Target_Missing_Flag=true;
			  count1++;
			  Dele_Tgt.add(key);
				 
			  if(count1<=200) {
			 
			  record_Target.add("Present in Target But not in Source | "+key);
			  }
			 
		  }
    	
    } 
    
    for (String key : Dele_Src)  {
    	
    	Src_Map.remove(key);
    	
    }
    

    for (String key : Dele_Tgt)  {
    	
    	Tgt_Map.remove(key);
    	
    }
    
    

    
		  System.out.println("record size of traget msiign : "+count1); 
		  Tgt_missing_count=count1;
		 
		
		  Src_missing_count=count;
				
		  System.out.println("record size of source msiign : "+Src_missing_count); 
	   
		Missing_Record_Bulk_Writer(Result_File,Source_Missing,record_Source);
		Missing_Record_Bulk_Writer(Result_File,Target_Missing,record_Target);
	      
		System.out.println("Missing record end");
		
		record_Target.clear();
		record_Source.clear();
		
		
		 long stopTime = System.currentTimeMillis();
		 long elapsedTime = stopTime - startTime;
		 System.out.println("Missing time Taken:"+elapsedTime/1000+ " Seconds");
	
	
	
}



public void spliter1() {
	
	  Iterator value = Temp_Src_data.iterator(); 
	  
      while (value.hasNext()) { 
    	  
    	  String[] act=value.next().toString().split("\\|");
		  
			String key_val="";
			String val="";
			int key_start=0;
			int nonkey_start=0;
			
			 for(int j=0;j<act.length;j++) {
					
				  if(Key_Column_identifier(j)) {
					  
					  key_start++;
					  
					  String v=act[j]; 
						 if(key_start==1) {
							
							 if (Strings.isNullOrEmpty(v)) {
								  key_val=key_val+"";
							  }
							  else {
								  key_val=key_val+v.trim();
							  }
							 
						 }
						 else {
							 
							 if (Strings.isNullOrEmpty(v)) {
								  key_val=key_val+" | "+"";
							  }
							  else {
								  key_val=key_val+" | "+v.trim();
							  }
							 
						 }
						 
					 }
						 else {
							 nonkey_start++;
							 String v=act[j]; 
							 if(nonkey_start==1) {
								
								 if (Strings.isNullOrEmpty(v)) {
									 val=val+"";
								  }
								  else {
									  val=val+v.trim();
								  }
								 
							 }
							 else {
								 
								 if (Strings.isNullOrEmpty(v)) {
									 val=val+" | "+"";
								  }
								  else {
									  val=val+" | "+v.trim();
								  }
								 
							 }
							 
					  
				  }
				  
			 }
			 
    	  
			 Src_Map.put(key_val,val);
    	  
      
      }
      
      
   Iterator value1 = Temp_Tgt_data.iterator(); 
	  
      while (value1.hasNext()) { 
    	  
    	  String[] act=value1.next().toString().split("\\|");
		  
			String key_val="";
			String val="";
			int key_start=0;
			int nonkey_start=0;
			
			 for(int j=0;j<act.length;j++) {
					
				  if(Key_Column_identifier(j)) {
					  key_start++;
					  
					  String v=act[j]; 
						 if(key_start==1) {
							
							 if (Strings.isNullOrEmpty(v)) {
								  key_val=key_val+"";
							  }
							  else {
								  key_val=key_val+v.trim();
							  }
							 
						 }
						 else {
							 
							 if (Strings.isNullOrEmpty(v)) {
								  key_val=key_val+" | "+"";
							  }
							  else {
								  key_val=key_val+" | "+v.trim();
							  }
							 
						 }
						 
					 }
						 else {
							 nonkey_start++;
							 
							 String v=act[j]; 
							 if(nonkey_start==1) {
								
								 if (Strings.isNullOrEmpty(v)) {
									 val=val+"";
								  }
								  else {
									  val=val+v.trim();
								  }
								 
							 }
							 else {
								 
								 if (Strings.isNullOrEmpty(v)) {
									 val=val+" | "+"";
								  }
								  else {
									  val=val+" | "+v.trim();
								  }
								 
							 }
							 
					  
				  }
				  
			 }
			 
    	  
			 Tgt_Map.put(key_val,val);
    	  
      
      }
	
	
	
	
}




   public void Data_Validation() throws IOException{
	  
	int count=0;
		
	boolean Sta;
	
	System.out.println(Tgt_Map.size()+"------"+Src_Map.size());
	
	if(Non_Primary) {

	
	ArrayList<String> data_write = new ArrayList<String>();
	
	
	
	Header_data_mismatch(Result_File,Data_Mismatch);
	
		
		        for (String key : Tgt_Map.keySet()) {
		        	 Sta=false;
		        	 
		        	
		 

				if(Tgt_Map.get(key).equals(Src_Map.get(key))) {
					
				}
				else {
					
					count++;
					
					Data_Mismatch_Flag=true;
					
					String[] Tgt_val=Tgt_Map.get(key).split("\\|");
					String[] Src_val=Src_Map.get(key).split("\\|");
					
					String val="";
					
					
					for(int i=0;i<Tgt_val.length;i++) {
						
						if(!(Tgt_val[i].trim().equalsIgnoreCase(Src_val[i].trim()))) {
							
		
							 if(val.length()==0) {
							
								val=val+Tgt_val[i]+" | "+Src_val[i]+" | MisMatch ";
							 }
							 else {
								 
								 val=val+" | "+Tgt_val[i]+" | "+Src_val[i]+" | MisMatch ";
								 
							 }
							
							
							Column_Mismatch.put(i+1, Column_Mismatch.get(i+1)+1);
							
							if(Column_Mismatch.get(i+1)<=10) {
								
								Sta=true;
							}
						}
						
						else {
							
							 if(val.length()==0) {
									
									val=val+Tgt_val[i]+" | "+Src_val[i]+" | Match ";
								 }
								 else {
									 
									 val=val+" | "+Tgt_val[i]+" | "+Src_val[i]+" | Match ";
									 
								 }
						}
						
						
						
					}
					
					if(Sta){
						
						data_write.add(key+" | "+val);
						
					}
					
					
					
				}
			}
		
		        Data_mismatch_count=count;
		        
		      
		   
		       Data_validation_Bulk_Writer(Result_File,Data_Mismatch,data_write);
	}
	else {
		
		Header_No_pri(Result_File,Data_Mismatch);
		
		
		
	}
	
	
		
		   	  
}





    
    public void Key_Value_Split() {
    	
    	 String[] Keyvalue_Split=Key_Column.split(",");
		  Keyvalue_Column=new int[Keyvalue_Split.length];
		  for(int x=0;x<Keyvalue_Split.length;x++){
		    	
		    	Keyvalue_Column[x]=Integer.parseInt(Keyvalue_Split[x])-1;
	
		    	
		    }
		 
    	
    }
    
    
    
    
    

    public  void Hive_HDBC(String Username,String Pwd) throws ClassNotFoundException, SQLException{
     	  
   	   Class.forName(driverName_Hive);
   	   con = DriverManager.getConnection("jdbc:hive2://hiveldap.aetna.com:10000/default;AuthMech=3;",Username,Pwd);
   	   stmt = con.createStatement();
   	   System.out.println("Hive Connection Success");
       }
      
      public  void DB_Close() throws ClassNotFoundException, SQLException{
      	con.close();
      	
       	
       }
      
      public  void DB2_jDBC(String Username,String Pwd,String DB,String port ,String host) throws ClassNotFoundException, SQLException{
     	  
      	   Class.forName(driverName_DB2);
      	   
      	 //db2ctqa1
      	 //db2ctprd1
      	 con = DriverManager.getConnection("jdbc:db2://"+host+":"+port+"/"+DB,Username,Pwd);
      	stmt = con.createStatement();
      	
      	   System.out.println("DB2 Connection Success");
          }
       
      
      public  void SQL_Server(String Server,String DB) throws ClassNotFoundException, SQLException{
   	  
   	   Class.forName(driverName_Sql);
   	   if(Strings.isNullOrEmpty(DB)) {
   		con = DriverManager.getConnection("jdbc:sqlserver://"+Server+":1433;integratedSecurity=true");  
   	   }
   	   else {
   	   con = DriverManager.getConnection("jdbc:sqlserver://"+Server+":1433;DatabaseName="+DB+";integratedSecurity=true");
   	   }
   	  stmt = con.createStatement();
   	
   	  System.out.println("Sql Server Connection Success");
   	  
   	 
       	
       }
      
      public  void Netezza(String Username,String Pwd,String DB ,String server) throws ClassNotFoundException, SQLException{
     	  
     	   Class.forName(driverName_Nete);
     	   
   
     	 con = DriverManager.getConnection("jdbc:netezza://"+server+"/"+DB,Username,Pwd);
     	stmt = con.createStatement();
     	
     	   System.out.println("Netezza Connection Success");
         }
      
      
     
      
      public  String[][] readXLSX(String Filepath,String Sheet) throws IOException{
   		File excel=new File(Filepath);
   		FileInputStream fis=new FileInputStream(excel);
   		String Value=null;
   		XSSFWorkbook book=new XSSFWorkbook(fis);
   		XSSFSheet ws=book.getSheet(Sheet);
   		XSSFCell cell;
   		
   		DataFormatter format=new DataFormatter();
   		long rowNum=ws.getLastRowNum()+1;
   		long colNum=ws.getRow(0).getLastCellNum();
   		
   		String[][] Parameter=new String[(int)colNum][(int)rowNum];
   		for(int i=0;i<rowNum;i++){
   			XSSFRow row=ws.getRow(i);
   			for(int j=0;j<colNum;j++){
   				
   				cell=row.getCell(j);
   				if(!(cell==null)){
   					Value=format.formatCellValue(cell);
   				}
   				else{
   					Value="";
   				}
   				Parameter[j][i]=Value;
   			}
   			
   		}
   		book.close();
   		return Parameter;
   		
   	}
       
      
      public  boolean isStringEmpty(String input){
          if(input.trim().length() == 0){
              return true;
          }
          return false;
      }
  	
  	public  boolean isStringNull(String input){
  	
          if(input == null ){
              return true;
          }
          return false;
      }
  	
public  void Create_Sheet(String Filepath,String Sheet) throws IOException{
 		
 		FileInputStream fis=new FileInputStream(Filepath);
 		XSSFWorkbook book=new XSSFWorkbook(fis);
 		XSSFSheet ws=book.createSheet(Sheet);
 		
 		if(Sheet.equalsIgnoreCase("Summary")){
 			book.setSheetOrder("Summary", 0);
 		}
 		fis.close();
 		FileOutputStream fo=new FileOutputStream(Filepath);
 		book.write(fo);
 		book.close();
 		fo.flush();
 		fo.close();
 		
 	}

public  void Create_workbook_Sheets() throws IOException{
	  
    Create_Book(Result_File);
	Create_Sheet(Result_File,Count_Report);
	Create_Sheet(Result_File,Source_Duplicate);
	Create_Sheet(Result_File,Target_Duplicate);
	Create_Sheet(Result_File,Source_Missing);
	Create_Sheet(Result_File,Target_Missing);
	//Create_Sheet(Result_File,Missing_Record);
	Create_Sheet(Result_File,Data_Mismatch);
	Create_Sheet(Result_File,Summary);
  
  
}
 	

 	
 public  String Create_Book(String Filepath) throws IOException{
 	
 		String FP=Filepath;
 		XSSFWorkbook workbook = new XSSFWorkbook();
 	    FileOutputStream out = new FileOutputStream(new File(FP));
 	      workbook.write(out);
 	      out.close();
 	      return FP;
 			
 		}
 
 
 public void File_Copy(String Src,String Desc) throws InterruptedException, IOException{
		File f1= new File(Src);
		File f2= new File(Desc);
		FileUtils.copyFile(f1, f2);

	}
 
 public void Restart_server(String url) throws InterruptedException, IOException{
		Runtime runtime = Runtime.getRuntime();
		System.out.println(runtime);
		Process p1 = runtime.exec("cmd /c start chrome "+url);
		Thread.sleep(10000);
		p1.destroy();
	}
 
 
 public void Source_Excel_Exe() throws SQLException, ClassNotFoundException, IOException {
	 	
	 
	  HashSet<String> Coll = new HashSet<String>(); 
	  String[] ll = null;
		InputStream is = new FileInputStream(new File(Input_File_Path_Source));
		Workbook workbook = StreamingReader.builder()
		        .rowCacheSize(100)   
		        .bufferSize(4096)    
		        .open(is); 
		
		 Sheet s = workbook.getSheet("Sheet1");
		 
		 long Src_count=0;
		 int jj=0;
		 int rr=0;
		
		 for (Row r : s) {
			 
			 String key_val="";
			
			 int i=0;
			 int gg=0;
			 int ff=0;
			 if(rr==0) {
				 Src_Column_Count=r.getLastCellNum();
				 ll=new String[Src_Column_Count];
				 rr++;
			 }
			 
			 for(int kk=0;kk<Src_Column_Count;kk++) {
			    	
			         if(jj==0) {
			        	
					        Cell c=r.getCell(kk);
			        	
						 //Src_Column_Count=r.getLastCellNum();
						 Coll.add(c.getStringCellValue());
			        	
			        	 ll[kk]=c.getStringCellValue();
			        	if(!(Key_Column_identifier(i))) {
			        		 gg++;
			        	 Column_Mismatch.put(gg, (long)0);
						// Temp_Column_Mismatch.put(c.getStringCellValue(), (long)0);
						 Table_column.put(gg,c.getStringCellValue().trim());
			        	 }
			        	else {
			        		
			    				ff++;
			    				
			    				Table_column_key.put(ff,c.getStringCellValue().trim());
			    				
			    			
			        	}
			        	 i++;
			        	 
			         }
			         else {
			        	 
			        	 String v; 
					      Cell c=r.getCell(kk);
	
					      if(!(c==null)){
			 					v=c.getStringCellValue();
			 				}
			 				else{
			 					v="";
			 				} 
						 if(kk==0) {
							
							 if (Strings.isNullOrEmpty(v)) {
								  key_val=key_val+"";
							  }
							  else {
								  key_val=key_val+v.trim();
							  }
							 
						 }
						 else {
							 
							 if (Strings.isNullOrEmpty(v)) {
								  key_val=key_val+" | "+"";
							  }
							  else {
								  key_val=key_val+" | "+v.trim();
							  }
							 
						 }
						 
					 }
			         }
			    
			   
			   
			    if(jj==0){
			    	 jj++;
			    }
			    else {
			    	 Src_count++;
			    	 int temp=Src_data.size();
					   Src_data.add(key_val);
					 if(temp==Src_data.size()) {
						 Src_duplicate.add(key_val);
					 }
			    	
			    }
			   
				 
				 
					}
		 
		 
		 
		 
		 Src_Column_Name =ll;
		 
		 if(Src_Column_Name.length==Keyvalue_Column.length) {
	   		 Non_Primary=false; 
	   	 }
		
			  
		 Total_Src_Count=Src_count;
		 Total_Src_Count_no_dup=Src_data.size();
		 Src_duplicate_count=Src_duplicate.size();
		 System.out.println("Srctotal count : "+Total_Src_Count);
		 System.out.println("Srctotal count no dup : "+Total_Src_Count_no_dup);
		 System.out.println("Src Duplicate Record count : "+Src_duplicate_count);
		 
		 Source_dup();
		
		 System.out.println("Source completed");
	 }
 
 
 
 public void Target_Excel_Exe() throws SQLException, ClassNotFoundException, IOException {
	 
	 HashSet<String> Coll = new HashSet<String>(); 
	 String[] ll = null;
		InputStream is = new FileInputStream(new File(Input_File_Path_Target));
		Workbook workbook = StreamingReader.builder()
		        .rowCacheSize(100)   
		        .bufferSize(4096)    
		        .open(is); 
		
		 Sheet s = workbook.getSheet("Sheet1");
		 
		 long Tgt_count=0;
		 int jj=0;
		 int rr=0;
		
		 for (Row r : s) {
			 
			 String key_val="";
			
			 int i=0;
			 int gg=0;
			 if(rr==0) {
				 Tgt_Column_Count=r.getLastCellNum();
				 ll=new String[Tgt_Column_Count];
				 rr++;
			 }
			 
			 for(int kk=0;kk<Tgt_Column_Count;kk++) {
			    	
			         if(jj==0) {
			        	
					        Cell c=r.getCell(kk);
			        	
						 //Tgt_Column_Count=r.getLastCellNum();
						 Coll.add(c.getStringCellValue());
						 ll[kk]=c.getStringCellValue();
			        	 
			        
			        	 i++;
			        	 
			         }
			         else {
			        	 
			        	 String v; 
					      Cell c=r.getCell(kk);
	
					      if(!(c==null)){
			 					v=c.getStringCellValue();
			 				}
			 				else{
			 					v="";
			 				} 
						 if(kk==0) {
							
							 if (Strings.isNullOrEmpty(v)) {
								  key_val=key_val+"";
							  }
							  else {
								  key_val=key_val+v.trim();
							  }
							 
						 }
						 else {
							 
							 if (Strings.isNullOrEmpty(v)) {
								  key_val=key_val+" | "+"";
							  }
							  else {
								  key_val=key_val+" | "+v.trim();
							  }
							 
						 }
						 
					 }
			         }
			    
			   
			   
			    if(jj==0){
			    	 jj++;
			    }
			    else {
			    	 Tgt_count++;
			    	 int temp=Tgt_data.size();
					   Tgt_data.add(key_val);
					 if(temp==Tgt_data.size()) {
						 Tgt_duplicate.add(key_val);
					 }
			    	
			    }
			   
				 
				 
					}
		 
		 
		 
		
		 Tgt_Column_Name =ll;
		 
		 if(Tgt_Column_Name.length==Keyvalue_Column.length) {
	   		 Non_Primary=false; 
	   	 }
		 
		
		
			  
		 Total_Tgt_Count=Tgt_count;
		 Total_Tgt_Count_no_dup=Tgt_data.size();
		 Tgt_duplicate_count=Tgt_duplicate.size();
		 System.out.println("Tgttotal count : "+Total_Tgt_Count);
		 System.out.println("Tgttotal count no dup : "+Total_Tgt_Count_no_dup);
		 System.out.println("Tgt Duplicate Record count : "+Tgt_duplicate_count);
		 
		 Target_dup();
		
 }
 
 public void Summary_sheet() throws IOException{	
	 
	 Summary_Write(Result_File,Summary);
	
	
}
 
 
 public String[] Uncommon(String src,String type) throws FileNotFoundException{
		String[] FinalData = null;
		
		
		if(!(type.equalsIgnoreCase("Excel"))) {
		String data=src.replaceAll("\\s+", " ").trim();
		String[] data1=data.split("\\bfrom\\b");
		System.out.println(data1[0]);
		String dd2=data1[0].replace("select", "");
		dd2=dd2.trim();
		System.out.println("-----------------------");
		System.out.println(dd2);
		String[] dd3=dd2.split(",");
		FinalData=new String[dd3.length];
		
		for(int i=0;i<dd3.length;i++){
			
			String bb=dd3[i].trim();
			//if(bb.split(" ").length==1){
				
				FinalData[i]=bb;
				
				
			//}
			//else{
				
				//String[] dd4=bb.split("\\bas\\b");
				//String cc=dd4[1].trim();
				//FinalData[i]=cc;
			
				
			//}
		}
		}
		else {
			
			InputStream is = new FileInputStream(new File(src));
			Workbook workbook = StreamingReader.builder()
			        .rowCacheSize(100)   
			        .bufferSize(4096)    
			        .open(is); 
			
			 Sheet s = workbook.getSheet("Sheet1");
			 
		
			 int rr=0;
			  int ll=0;
			 for (Row r : s) {
				 
				 if(rr==0) {
					 ll =r.getLastCellNum();
					 FinalData=new String[ll];
					 rr++;
				 }
				 
				 else {
					 break;
				 }
				 
				 for(int kk=0;kk<ll;kk++) {
				    	
				       
				        	
						        Cell c=r.getCell(kk);
						        FinalData[kk]=c.getStringCellValue();
							
				        	 
				        
				 }
				 
				
			 }
			
			
			
		}
		
		return FinalData;
		
		
		
	}



 public String[] Uncommon_csv(String src) throws FileNotFoundException{
	 
	 String[] FinalData = null;
	 
	 
     String[] data1=src.split(",");
     FinalData=new String[data1.length];
     
     for(int i=0;i<data1.length;i++) {
    	 
    	 FinalData[i]=data1[i].trim();
     }
	 
	 
	 
	 
	 return FinalData;
 }
 
 public String[] Uncommon_Mainframe(String src) throws IOException{
	 String[] FinalData = null;
	 
	 String[][] data=readXLSX(src,"Copybook");
	 int j=0;
	 
	 for(int i=1;i<data[0].length;i++) {
		 
		 FinalData[j]=data[0][i];
		 j++;
	 }
	 
	 
	 
	 
	 return FinalData;
	 
	 
 }
 
 
 public void Source_Delimiter_Exe() throws IOException{
	 	
		
	  BufferedReader reader1 = new BufferedReader(new FileReader(Input_File_Path_Source));
	  long Src_count=0;
	  int len=0;
    
     Src_Column_Name=Src_Col_Name.split(",");
     Src_Column_Count=Src_Column_Name.length;
     int gg=0;
     int ff=0;
     
     for(int i=0;i<Src_Column_Name.length;i++)
     {
   	  
     if(!(Key_Column_identifier(i))) {
		 gg++;
	     Column_Mismatch.put(gg, (long)0);
		 Table_column.put(gg,Src_Column_Name[i].trim());
	 }
     else {
    	 
    	 ff++;
			
	   Table_column_key.put(ff,Src_Column_Name[i].trim());
    	 
     }
     
     }
     
     String line1 = reader1.readLine();
		
     
     while (line1 != null)
     {
   	  String key_val="";
   	  
   	  String[] v=line1.split(Src_Symbol) ;
   	  
   	  if(Src_EOR.equalsIgnoreCase("Yes")) {
   		  len=v.length-1;
   	  }
   	  else {
   		   len=v.length;
   	  }
   	 
   	  
   	  for(int i=0;i<len;i++)
         {
   		 
   		  if(i==0) {
   			  
   			  if (Strings.isNullOrEmpty(v[i])) {
					  key_val=key_val+"";
				  }
				  else {
					  key_val=key_val+v[i].trim();
				  }
				 
   			  
   		  }
   		  else {
   			  
   			  if (Strings.isNullOrEmpty(v[i])) {
					  key_val=key_val+" | "+"";
				  }
				  else {
					  key_val=key_val+" | "+v[i].trim();
				  }
   			   
         }
   	  
         }
   	  
   	  
   	     Src_count++;
	    	 int temp=Src_data.size();
			   Src_data.add(key_val);
			 if(temp==Src_data.size()) {
				 Src_duplicate.add(key_val);
			 }
   	  
   	  
   	  line1 = reader1.readLine();
         
          
     }
			
     
     reader1.close();
		 
		 if(Src_Column_Name.length==Keyvalue_Column.length) {
	   		 Non_Primary=false; 
	   	 }
		   
		 Total_Src_Count=Src_count;
		 Total_Src_Count_no_dup=Src_data.size();
		 Src_duplicate_count=Src_duplicate.size();
		 System.out.println("Srctotal count : "+Total_Src_Count);
		 System.out.println("Srctotal count no dup : "+Total_Src_Count_no_dup);
		 System.out.println("Src Duplicate Record count : "+Src_duplicate_count);
		 
		 Source_dup();
		
		 System.out.println("Source completed");
	 }
 
 
 public void Target_Delimiter_Exe() throws IOException{
	 	
		
	  BufferedReader reader1 = new BufferedReader(new FileReader(Input_File_Path_Target));
	  long Tgt_count=0;
	  int len=0;
   
    Tgt_Column_Name=Src_Col_Name.split(",");
    Tgt_Column_Count=Src_Column_Name.length;
   
    
    String line1 = reader1.readLine();
		
    
    while (line1 != null)
    {
  	  String key_val="";
  	  
  	  String[] v=line1.split(Tgt_Symbol) ;
  	  
  	  if(Tgt_EOR.equalsIgnoreCase("Yes")) {
  		  len=v.length-1;
  	  }
  	  else {
  		   len=v.length;
  	  }
  	 
  	  
  	  for(int i=0;i<len;i++)
        {
  		 
  		  if(i==0) {
  			  
  			  if (Strings.isNullOrEmpty(v[i])) {
					  key_val=key_val+"";
				  }
				  else {
					  key_val=key_val+v[i].trim();
				  }
				 
  			  
  		  }
  		  else {
  			  
  			  if (Strings.isNullOrEmpty(v[i])) {
					  key_val=key_val+" | "+"";
				  }
				  else {
					  key_val=key_val+" | "+v[i].trim();
				  }
  			   
        }
  	  
        }
  	  
  	  
  	Tgt_count++;
	    	 int temp=Tgt_data.size();
			   Tgt_data.add(key_val);
			 if(temp==Tgt_data.size()) {
				 Tgt_duplicate.add(key_val);
			 }
  	  
  	  
  	  line1 = reader1.readLine();
        
         
    }
			
    
    reader1.close();
		 
		 if(Tgt_Column_Name.length==Keyvalue_Column.length) {
	   		 Non_Primary=false; 
	   	 }
		   
		 Total_Tgt_Count=Tgt_count;
		 Total_Tgt_Count_no_dup=Src_data.size();
		 Tgt_duplicate_count=Tgt_duplicate.size();
		 System.out.println("Srctotal count : "+Total_Tgt_Count);
		 System.out.println("Srctotal count no dup : "+Total_Tgt_Count_no_dup);
		 System.out.println("Src Duplicate Record count : "+Tgt_duplicate_count);
		 
		 Target_dup();
		
		 System.out.println("Target completed");
	 }
 
 
 public void Source_Mainframe_Exe() throws IOException, InterruptedException{
	 
	 
	 File_Copy(Src_File_mainframe_path,Input_File_Path_Source);
	 String[][] mydata=readXLSX(Src_Copy_book,"Copybook");
		
		for(int i=1;i<mydata[0].length;i++) {
			
			if(i==1) {
			
			Src_Col_Name=mydata[0][i];
			}
			else {
			Src_Col_Name=Src_Col_Name+" , "+mydata[0][i];
				
			}
			
		}
		
		 BufferedReader reader1 = new BufferedReader(new FileReader(Input_File_Path_Source));
		  long Src_count=0;
		  int len=0;
	   
	      Src_Column_Name=Src_Col_Name.split(",");
	      Src_Column_Count=Src_Column_Name.length;
	      
	      int gg=0,ff=0;
	      
	      for(int h=0;h<Src_Column_Count;h++) {
	    	  
	    	  if(!(Key_Column_identifier(h))) {
	    			 gg++;
	    		     Column_Mismatch.put(gg, (long)0);
	    			 Table_column.put(gg,Src_Column_Name[h].trim());
	    		 }
	    	     else {
	    	    	 
	    	    	 ff++;
	    				
	    		   Table_column_key.put(ff,Src_Column_Name[h].trim());
	    	    	 
	    	     }
	    	     
	    	  
	      }
	   
	    
	    String line1 = reader1.readLine();
			
	    
	    while (line1 != null)
	    {
	  	  String key_val="";
	  	  
	  	  
	  	  for(int i=1;i<mydata[0].length;i++)
	        {
	  		  
	  		  int start=Integer.parseInt(mydata[1][i])-1;
	  		  int end=start + Integer.parseInt(mydata[2][i]);
	  		  String v=line1.substring(start, end);
	  		 
	  		  if(i==1) {
	  			  
	  			  if (Strings.isNullOrEmpty(v)) {
						  key_val=key_val+"";
					  }
					  else {
						  key_val=key_val+v.trim();
					  }
					 
	  			  
	  		  }
	  		  else {
	  			  
	  			  if (Strings.isNullOrEmpty(v)) {
						  key_val=key_val+" | "+"";
					  }
					  else {
						  key_val=key_val+" | "+v.trim();
					  }
	  			   
	        }
	  	  
	        }
	  	  
	  	  
	  	     Src_count++;
		    	 int temp=Src_data.size();
				   Src_data.add(key_val);
				 if(temp==Src_data.size()) {
					 Src_duplicate.add(key_val);
				 }
	  	  
	  	  
	  	  line1 = reader1.readLine();
	        
	         
	    }
				
	    
	    reader1.close();
	    
	    if(Src_Column_Name.length==Keyvalue_Column.length) {
	   		 Non_Primary=false; 
	   	 }
		   
		 Total_Src_Count=Src_count;
		 Total_Src_Count_no_dup=Src_data.size();
		 Src_duplicate_count=Src_duplicate.size();
		 System.out.println("Srctotal count : "+Total_Src_Count);
		 System.out.println("Srctotal count no dup : "+Total_Src_Count_no_dup);
		 System.out.println("Src Duplicate Record count : "+Src_duplicate_count);
		 
		 Source_dup();
		
			 
	
	 
	 
 }
 
public void Target_Mainframe_Exe() throws IOException, InterruptedException{
	 
	 
	 File_Copy(Tgt_File_mainframe_path,Input_File_Path_Target);
	 String[][] mydata=readXLSX(Tgt_Copy_book,"Copybook");
		
		for(int i=1;i<mydata[0].length;i++) {
			
			if(i==1) {
			
			Tgt_Col_Name=mydata[0][i];
			}
			else {
			Tgt_Col_Name=Tgt_Col_Name+" , "+mydata[0][i];
				
			}
			
		}
		
		 BufferedReader reader1 = new BufferedReader(new FileReader(Input_File_Path_Target));
		  long Tgt_count=0;
		  int len=0;
	   
	      Tgt_Column_Name=Tgt_Col_Name.split(",");
	      Tgt_Column_Count=Tgt_Column_Name.length;
	   
	    
	    String line1 = reader1.readLine();
			
	    
	    while (line1 != null)
	    {
	  	  String key_val="";
	  	  
	  	  
	  	  for(int i=1;i<mydata[0].length;i++)
	        {
	  		  
	  		  int start=Integer.parseInt(mydata[1][i])-1;
	  		  int end=start + Integer.parseInt(mydata[2][i]);
	  		  String v=line1.substring(start, end);
	  		 
	  		  if(i==1) {
	  			  
	  			  if (Strings.isNullOrEmpty(v)) {
						  key_val=key_val+"";
					  }
					  else {
						  key_val=key_val+v.trim();
					  }
					 
	  			  
	  		  }
	  		  else {
	  			  
	  			  if (Strings.isNullOrEmpty(v)) {
						  key_val=key_val+" | "+"";
					  }
					  else {
						  key_val=key_val+" | "+v.trim();
					  }
	  			   
	        }
	  	  
	        }
	  	  
	  	  
	  	     Tgt_count++;
		    	 int temp=Tgt_data.size();
				   Tgt_data.add(key_val);
				 if(temp==Tgt_data.size()) {
					 Tgt_duplicate.add(key_val);
				 }
	  	  
	  	  
	  	  line1 = reader1.readLine();
	        
	         
	    }
				
	    
	    reader1.close();
	    
	    if(Tgt_Column_Name.length==Keyvalue_Column.length) {
	   		 Non_Primary=false; 
	   	 }
		   
		 Total_Tgt_Count=Tgt_count;
		 Total_Tgt_Count_no_dup=Tgt_data.size();
		 Tgt_duplicate_count=Tgt_duplicate.size();
		 System.out.println("Tgttotal count : "+Total_Tgt_Count);
		 System.out.println("Tgttotal count no dup : "+Total_Tgt_Count_no_dup);
		 System.out.println("Tgt Duplicate Record count : "+Tgt_duplicate_count);
		 
		 Target_dup();
		
			 
	
	 
	 
 }
 
 
 public  void Header_Duplicate(String Filepath,String Sheet,String[] act) throws IOException{
		
	 FileInputStream inputStream = new FileInputStream(Filepath);
     XSSFWorkbook wb_template = new XSSFWorkbook(inputStream);
     inputStream.close();

     SXSSFWorkbook wb = new SXSSFWorkbook(wb_template); 
     wb.setCompressTempFiles(true);

     SXSSFSheet sh = (SXSSFSheet) wb.getSheet(Sheet);
     sh.setRandomAccessWindowSize(100);
     
     XSSFCellStyle lock=(XSSFCellStyle) wb.createCellStyle();
     lock.setAlignment(HorizontalAlignment.LEFT);
     XSSFFont font= (XSSFFont) wb.createFont();
     font.setFontHeightInPoints((short)10);
     font.setFontName("Verdana");
     font.setColor(IndexedColors.BLACK.getIndex());
     font.setBold(true);
     font.setItalic(false);
     lock.setFont(font);
     lock.setBorderTop(BorderStyle.MEDIUM);
     lock.setBorderRight(BorderStyle.MEDIUM);
     lock.setBorderBottom(BorderStyle.MEDIUM);
     lock.setBorderLeft(BorderStyle.MEDIUM);
     
     
         Row row = sh.createRow(0);
        
         for(int i=0;i<act.length;i++){
        	// sh.autoSizeColumn(i);
        	 Cell cell = row.createCell(i);  
        	 if(Strings.isNullOrEmpty(act[i])){
	        	 cell.setCellValue(act[i]);
	        	 }
	        	 else {
	        		 cell.setCellValue(act[i].trim()); 
	        	 }
        	 cell.setCellStyle(lock);
         }
           

 


 FileOutputStream out = new FileOutputStream(Filepath);
 wb.write(out);
 out.close();
}


public  void Header_Missing_Src(String Filepath,String Sheet) throws IOException{
	
	 FileInputStream inputStream = new FileInputStream(Filepath);
     XSSFWorkbook wb_template = new XSSFWorkbook(inputStream);
     inputStream.close();

     SXSSFWorkbook wb = new SXSSFWorkbook(wb_template); 
     wb.setCompressTempFiles(true);

     SXSSFSheet sh = (SXSSFSheet) wb.getSheet(Sheet);
     sh.setRandomAccessWindowSize(100);
     
     XSSFCellStyle lock=(XSSFCellStyle) wb.createCellStyle();
     lock.setAlignment(HorizontalAlignment.LEFT);
     XSSFFont font= (XSSFFont) wb.createFont();
     font.setFontHeightInPoints((short)10);
     font.setFontName("Verdana");
     font.setColor(IndexedColors.BLACK.getIndex());
     font.setBold(true);
     font.setItalic(false);
     lock.setFont(font);
     lock.setBorderTop(BorderStyle.MEDIUM);
     lock.setBorderRight(BorderStyle.MEDIUM);
     lock.setBorderBottom(BorderStyle.MEDIUM);
     lock.setBorderLeft(BorderStyle.MEDIUM);
     
     
       Row row = sh.createRow(0);
       Cell cell1 = row.createCell(0); 
       cell1.setCellValue("Error Desc");
       
         int i=1;
        
         for(int aa=0;aa<Keyvalue_Column.length;aa++){
        	
        	 Cell cell = row.createCell(i); 
        	     
  
	        	 cell.setCellValue(Src_Column_Name[Keyvalue_Column[aa]]);
        	     
	        		
	        	
        	 cell.setCellStyle(lock);
        	 i++;
         }
           

 


 FileOutputStream out = new FileOutputStream(Filepath);
 wb.write(out);
 out.close();
}

public  void Header_Missing_tgt(String Filepath,String Sheet) throws IOException{
	
	 FileInputStream inputStream = new FileInputStream(Filepath);
     XSSFWorkbook wb_template = new XSSFWorkbook(inputStream);
     inputStream.close();

     SXSSFWorkbook wb = new SXSSFWorkbook(wb_template); 
     wb.setCompressTempFiles(true);

     SXSSFSheet sh = (SXSSFSheet) wb.getSheet(Sheet);
     sh.setRandomAccessWindowSize(100);
     
     XSSFCellStyle lock=(XSSFCellStyle) wb.createCellStyle();
     lock.setAlignment(HorizontalAlignment.LEFT);
     XSSFFont font= (XSSFFont) wb.createFont();
     font.setFontHeightInPoints((short)10);
     font.setFontName("Verdana");
     font.setColor(IndexedColors.BLACK.getIndex());
     font.setBold(true);
     font.setItalic(false);
     lock.setFont(font);
     lock.setBorderTop(BorderStyle.MEDIUM);
     lock.setBorderRight(BorderStyle.MEDIUM);
     lock.setBorderBottom(BorderStyle.MEDIUM);
     lock.setBorderLeft(BorderStyle.MEDIUM);
     
     
       Row row = sh.createRow(0);
       Cell cell1 = row.createCell(0); 
       cell1.setCellValue("Error Desc");
         int i=1;
        
         for(int aa=0;aa<Keyvalue_Column.length;aa++){
        	
        	 Cell cell = row.createCell(i); 
        	     
  
	        	 cell.setCellValue(Tgt_Column_Name[Keyvalue_Column[aa]]);
        	     
	        		
	        	
        	 cell.setCellStyle(lock);
        	 i++;
         }
           

 


 FileOutputStream out = new FileOutputStream(Filepath);
 wb.write(out);
 out.close();
}

public  void Header_No_pri(String Filepath,String Sheet) throws IOException{
	
	 FileInputStream inputStream = new FileInputStream(Filepath);
     XSSFWorkbook wb_template = new XSSFWorkbook(inputStream);
     inputStream.close();

     SXSSFWorkbook wb = new SXSSFWorkbook(wb_template); 
     wb.setCompressTempFiles(true);

     SXSSFSheet sh = (SXSSFSheet) wb.getSheet(Sheet);
     sh.setRandomAccessWindowSize(100);
     
     XSSFCellStyle lock=(XSSFCellStyle) wb.createCellStyle();
     lock.setAlignment(HorizontalAlignment.LEFT);
     XSSFFont font= (XSSFFont) wb.createFont();
     font.setFontHeightInPoints((short)10);
     font.setFontName("Verdana");
     font.setColor(IndexedColors.BLACK.getIndex());
     font.setBold(true);
     font.setItalic(false);
     lock.setFont(font);
     lock.setBorderTop(BorderStyle.MEDIUM);
     lock.setBorderRight(BorderStyle.MEDIUM);
     lock.setBorderBottom(BorderStyle.MEDIUM);
     lock.setBorderLeft(BorderStyle.MEDIUM);
     
     
       Row row = sh.createRow(0);
       Cell cell1 = row.createCell(0); 
       cell1.setCellValue("No non Primary key columns");
         
	        		
	        	
        	 cell1.setCellStyle(lock);
        

 


 FileOutputStream out = new FileOutputStream(Filepath);
 wb.write(out);
 out.close();
}

public  void Header_data_mismatch(String Filepath,String Sheet) throws IOException{
	
	 FileInputStream inputStream = new FileInputStream(Filepath);
     XSSFWorkbook wb_template = new XSSFWorkbook(inputStream);
     inputStream.close();

     SXSSFWorkbook wb = new SXSSFWorkbook(wb_template); 
     wb.setCompressTempFiles(true);

     SXSSFSheet sh = (SXSSFSheet) wb.getSheet(Sheet);
     sh.setRandomAccessWindowSize(100);
     
     XSSFCellStyle lock=(XSSFCellStyle) wb.createCellStyle();
     lock.setAlignment(HorizontalAlignment.LEFT);
     XSSFFont font= (XSSFFont) wb.createFont();
     font.setFontHeightInPoints((short)10);
     font.setFontName("Verdana");
     font.setColor(IndexedColors.BLACK.getIndex());
     font.setBold(true);
     font.setItalic(false);
     lock.setFont(font);
     lock.setBorderTop(BorderStyle.MEDIUM);
     lock.setBorderRight(BorderStyle.MEDIUM);
     lock.setBorderBottom(BorderStyle.MEDIUM);
     lock.setBorderLeft(BorderStyle.MEDIUM);
     
     
       Row row = sh.createRow(0);
      
         int i=0;
        
         for(int aa=0;aa<Keyvalue_Column.length;aa++){
        	
        	     Cell cell = row.createCell(i); 
	        	 cell.setCellValue(Tgt_Column_Name[Keyvalue_Column[aa]]);
        	    	
        	 cell.setCellStyle(lock);
        	 i++;
         }
         
         for(int bb=0;bb<Tgt_Column_Name.length;bb++){
        	 
        	 if(!(Key_Column_identifier1(bb))) {
	        	
    	     Cell cell = row.createCell(i); 
        	 cell.setCellValue(Tgt_Column_Name[bb]+"_Target");	
    	     cell.setCellStyle(lock);
    	     i++;
    	     
    	     Cell cell1 = row.createCell(i); 
        	 cell1.setCellValue(Tgt_Column_Name[bb]+"_Source");	
    	     cell1.setCellStyle(lock);
    	     i++;
    	     
    	     Cell cell2 = row.createCell(i); 
        	 cell2.setCellValue(Tgt_Column_Name[bb]+"_Status");	
    	     cell2.setCellStyle(lock);
    	     i++;
    	 
        	 }
     }
           

 


 FileOutputStream out = new FileOutputStream(Filepath);
 wb.write(out);
 out.close();
}

 public  boolean Key_Column_identifier1(int i) {
		
	 boolean test = false; 
    for (int element : Keyvalue_Column) { 
        if (element == i) { 
            test = true; 
            break; 
        } 
    }
    
    if(test) {
   	 return true;
   	
    }
    else
   	 return false;
	
}




public  void Missing_Record_Bulk_Writer(String Filepath,String Sheet,ArrayList<String> map) throws IOException{
	
	 FileInputStream inputStream = new FileInputStream(Filepath);
     XSSFWorkbook wb_template = new XSSFWorkbook(inputStream);
     inputStream.close();

     SXSSFWorkbook wb = new SXSSFWorkbook(wb_template); 
     wb.setCompressTempFiles(true);

     SXSSFSheet sh = (SXSSFSheet) wb.getSheet(Sheet);
     sh.setRandomAccessWindowSize(100);
     
     XSSFCellStyle lock=(XSSFCellStyle) wb.createCellStyle();
     lock.setAlignment(HorizontalAlignment.LEFT);
     XSSFFont font= (XSSFFont) wb.createFont();
     font.setFontHeightInPoints((short)10);
     font.setFontName("Verdana");
     font.setColor(IndexedColors.BLACK.getIndex());
     font.setBold(false);
     font.setItalic(false);
     lock.setFont(font);
     lock.setBorderTop(BorderStyle.MEDIUM);
     lock.setBorderRight(BorderStyle.MEDIUM);
     lock.setBorderBottom(BorderStyle.MEDIUM);
     lock.setBorderLeft(BorderStyle.MEDIUM);
    
      for(int rownum = 1; rownum <= map.size(); rownum++){
         Row row = sh.createRow(rownum);
         
         String[] act=map.get(rownum-1).split(" \\| ");
        
         for(int i=0;i<act.length;i++){
        	// sh.autoSizeColumn(i);
        	 Cell cell = row.createCell(i);  
        	 if(Strings.isNullOrEmpty(act[i])){
	        	 cell.setCellValue(act[i]);
	        	 }
	        	 else {
	        		 cell.setCellValue(act[i].trim()); 
	        	 }
        	 cell.setCellStyle(lock);
         }
           

 }


 FileOutputStream out = new FileOutputStream(Filepath);
 wb.write(out);
 out.close();
}

public  void Data_validation_Bulk_Writer(String Filepath,String Sheet,ArrayList<String> map) throws IOException{
	
	 FileInputStream inputStream = new FileInputStream(Filepath);
     XSSFWorkbook wb_template = new XSSFWorkbook(inputStream);
     inputStream.close();

     SXSSFWorkbook wb = new SXSSFWorkbook(wb_template); 
     wb.setCompressTempFiles(true);

     SXSSFSheet sh = (SXSSFSheet) wb.getSheet(Sheet);
     sh.setRandomAccessWindowSize(100);
     
     XSSFCellStyle lock=(XSSFCellStyle) wb.createCellStyle();
     lock.setAlignment(HorizontalAlignment.LEFT);
     XSSFFont font= (XSSFFont) wb.createFont();
     font.setFontHeightInPoints((short)10);
     font.setFontName("Verdana");
     font.setColor(IndexedColors.BLACK.getIndex());
     font.setBold(false);
     font.setItalic(false);
     lock.setFont(font);
     lock.setBorderTop(BorderStyle.MEDIUM);
     lock.setBorderRight(BorderStyle.MEDIUM);
     lock.setBorderBottom(BorderStyle.MEDIUM);
     lock.setBorderLeft(BorderStyle.MEDIUM);
    
      for(int rownum = 1; rownum <= map.size(); rownum++){
         Row row = sh.createRow(rownum);
         
         String[] act=map.get(rownum-1).split(" \\| ");
        
         for(int i=0;i<act.length;i++){
        	// sh.autoSizeColumn(i);
        	 Cell cell = row.createCell(i);  
        	 if(Strings.isNullOrEmpty(act[i])){
	        	 cell.setCellValue(act[i]);
	        	 }
	        	 else {
	        		 cell.setCellValue(act[i].trim()); 
	        	 }
        	 cell.setCellStyle(lock);
         }
           

 }


 FileOutputStream out = new FileOutputStream(Filepath);
 wb.write(out);
 out.close();
}

public  void Sample_Bulk_Writer(String Filepath,String Sheet,ArrayList<String> map) throws IOException{
	
	 FileInputStream inputStream = new FileInputStream(Filepath);
     XSSFWorkbook wb_template = new XSSFWorkbook(inputStream);
     inputStream.close();

     SXSSFWorkbook wb = new SXSSFWorkbook(wb_template); 
     wb.setCompressTempFiles(true);

     SXSSFSheet sh = (SXSSFSheet) wb.getSheet(Sheet);
     sh.setRandomAccessWindowSize(100);
     
     XSSFCellStyle lock=(XSSFCellStyle) wb.createCellStyle();
     lock.setAlignment(HorizontalAlignment.LEFT);
     XSSFFont font= (XSSFFont) wb.createFont();
     font.setFontHeightInPoints((short)10);
     font.setFontName("Verdana");
     font.setColor(IndexedColors.BLACK.getIndex());
     font.setBold(false);
     font.setItalic(false);
     lock.setFont(font);
     lock.setBorderTop(BorderStyle.MEDIUM);
     lock.setBorderRight(BorderStyle.MEDIUM);
     lock.setBorderBottom(BorderStyle.MEDIUM);
     lock.setBorderLeft(BorderStyle.MEDIUM);
   
      
      for(int rownum = 1; rownum <= 50; rownum++){
    	  if(map.size()>=rownum) {
    	  
         Row row = sh.createRow(rownum);
         String[] act=map.get(rownum-1).split(" \\| ");
     
         for(int i=0;i<act.length;i++){
        	// sh.autoSizeColumn(i);
        	 Cell cell = row.createCell(i);  
        	 if(Strings.isNullOrEmpty(act[i])){
	        	 cell.setCellValue(act[i]);
	        	 }
	        	 else {
	        		 cell.setCellValue(act[i].trim()); 
	        	 }
        	 cell.setCellStyle(lock);
         }
           
    	  }
 }


 FileOutputStream out = new FileOutputStream(Filepath);
 wb.write(out);
 out.close();
}




public  void Duplicate_Bulk_Writer(String Filepath,String Sheet,ArrayList<String> map) throws IOException{
	
	 FileInputStream inputStream = new FileInputStream(Filepath);
     XSSFWorkbook wb_template = new XSSFWorkbook(inputStream);
     inputStream.close();

     SXSSFWorkbook wb = new SXSSFWorkbook(wb_template); 
     wb.setCompressTempFiles(true);

     SXSSFSheet sh = (SXSSFSheet) wb.getSheet(Sheet);
     sh.setRandomAccessWindowSize(100);
     
     XSSFCellStyle lock=(XSSFCellStyle) wb.createCellStyle();
     lock.setAlignment(HorizontalAlignment.LEFT);
     XSSFFont font= (XSSFFont) wb.createFont();
     font.setFontHeightInPoints((short)10);
     font.setFontName("Verdana");
     font.setColor(IndexedColors.BLACK.getIndex());
     font.setBold(false);
     font.setItalic(false);
     lock.setFont(font);
     lock.setBorderTop(BorderStyle.MEDIUM);
     lock.setBorderRight(BorderStyle.MEDIUM);
     lock.setBorderBottom(BorderStyle.MEDIUM);
     lock.setBorderLeft(BorderStyle.MEDIUM);
    
   
      for(int rownum = 1; rownum <= 100; rownum++){
    	  if(map.size()>=rownum) {
    	  
         Row row = sh.createRow(rownum);
         
         String[] act=map.get(rownum-1).split(" \\| ");
	     
         for(int i=0;i<act.length;i++){
         
        	// sh.autoSizeColumn(0);
        	 Cell cell = row.createCell(i);  
        	 if(Strings.isNullOrEmpty(act[i])){
	        	 cell.setCellValue(act[i]);
	        	 }
	        	 else {
	        		 cell.setCellValue(act[i].trim()); 
	        	 }
        	 cell.setCellStyle(lock);
         }
           
    	  }
 }


 FileOutputStream out = new FileOutputStream(Filepath);
 wb.write(out);
 out.close();
}

public  void Count_Write(String Filepath,String Sheet) throws IOException{
	
	 FileInputStream inputStream = new FileInputStream(Filepath);
     XSSFWorkbook wb_template = new XSSFWorkbook(inputStream);
     inputStream.close();

     SXSSFWorkbook wb = new SXSSFWorkbook(wb_template); 
     wb.setCompressTempFiles(true);

     SXSSFSheet sh = (SXSSFSheet) wb.getSheet(Sheet);
     sh.setRandomAccessWindowSize(100);
     
     XSSFCellStyle lock=(XSSFCellStyle) wb.createCellStyle();
     lock.setAlignment(HorizontalAlignment.LEFT);
     XSSFFont font= (XSSFFont) wb.createFont();
     font.setFontHeightInPoints((short)10);
     font.setFontName("Verdana");
     font.setColor(IndexedColors.BLACK.getIndex());
     font.setBold(true);
     font.setItalic(false);
     lock.setFont(font);
     lock.setBorderTop(BorderStyle.MEDIUM);
     lock.setBorderRight(BorderStyle.MEDIUM);
     lock.setBorderBottom(BorderStyle.MEDIUM);
     lock.setBorderLeft(BorderStyle.MEDIUM);
     
     int row_count=1;
     
             Row row1 = sh.createRow(row_count);
        	// sh.autoSizeColumn(row_count);
        	 Cell cell1 = row1.createCell(0); 
        	 Cell cell2 = row1.createCell(1); 
        	 cell1.setCellValue("Total Source count");
        	 cell2.setCellValue(String.valueOf(Total_Src_Count));
        	 cell1.setCellStyle(lock);
        	 cell2.setCellStyle(lock);
        	 
        	 
        	 row_count++;
        	 
        	 Row row2 = sh.createRow(row_count);
        	 //sh.autoSizeColumn(row_count);
        	 Cell cell3 = row2.createCell(0); 
        	 Cell cell4 = row2.createCell(1); 
        	 cell3.setCellValue("Total Target count");
        	 cell4.setCellValue(String.valueOf(Total_Tgt_Count));
        	 cell3.setCellStyle(lock);
        	 cell4.setCellStyle(lock);


        	 row_count= row_count+2;

        	 Row row3 = sh.createRow(row_count);
        	 //sh.autoSizeColumn(row_count);
        	 Cell cell5 = row3.createCell(0); 
        	 Cell cell6 = row3.createCell(1); 
        	 cell5.setCellValue("Total Source Duplicate");
        	 cell6.setCellValue(String.valueOf(Src_duplicate.size()));
        	 cell5.setCellStyle(lock);
        	 cell6.setCellStyle(lock);
        	 
        	 row_count++;
        	 
        	 Row row4 = sh.createRow(row_count);
        	// sh.autoSizeColumn(row_count);
        	 Cell cell7 = row4.createCell(0); 
        	 Cell cell8 = row4.createCell(1); 
        	 cell7.setCellValue("Total Target Duplicate");
        	 cell8.setCellValue(String.valueOf(Tgt_duplicate.size()));
        	 cell7.setCellStyle(lock);
        	 cell8.setCellStyle(lock);
        	 
        	 row_count= row_count+2;
        	 
        	 Row row5 = sh.createRow(row_count);
        	 //sh.autoSizeColumn(row_count);
        	 Cell cell9 = row5.createCell(0); 
        	 Cell cell10 = row5.createCell(1); 
        	 cell9.setCellValue("Source Missing count");
        	 cell10.setCellValue(String.valueOf(Src_missing_count));
        	 cell9.setCellStyle(lock);
        	 cell10.setCellStyle(lock);
        	 
        	 row_count++;
        	 
        	 Row row6 = sh.createRow(row_count);
        	 //sh.autoSizeColumn(row_count);
        	 Cell cell11 = row6.createCell(0); 
        	 Cell cell12 = row6.createCell(1); 
        	 cell11.setCellValue("Target Missing count");
        	 cell12.setCellValue(String.valueOf(Tgt_missing_count));
        	 cell11.setCellStyle(lock);
        	 cell12.setCellStyle(lock);
        	 
        	 row_count= row_count+2;
        	 
        	 Row row7 = sh.createRow(row_count);
        	 //sh.autoSizeColumn(row_count);
        	 Cell cell13 = row7.createCell(0);
        	 Cell cell14 = row7.createCell(1); 
        	 cell13.setCellValue("Total Data Mismatch Record");
        	 cell14.setCellValue(String.valueOf(Data_mismatch_count));
        	 cell13.setCellStyle(lock);
        	 cell14.setCellStyle(lock);
        	 
        	 
        	 row_count++;
        	 
        	 for(int i=1;i<=Column_Mismatch.size();i++) {
        			
        			if(Column_Mismatch.get(i)>0) {
        				
        				 Row row8 = sh.createRow(row_count);
        	        	 //sh.autoSizeColumn(row_count);
        	        	 Cell cell15 = row8.createCell(0);
        	        	 Cell cell16 = row8.createCell(1); 
        	        	 
        	        	 cell15.setCellValue(Table_column.get(i));
        	        	 cell16.setCellValue(String.valueOf(Column_Mismatch.get(i)));
        	        	 cell15.setCellStyle(lock);
        	        	 cell16.setCellStyle(lock);
        			
        	        	 row_count++;
        			}
        		}
        	 


 FileOutputStream out = new FileOutputStream(Filepath);
 wb.write(out);
 out.close();
}


public  void Summary_Write(String Filepath,String Sheet) throws IOException{
	
	 FileInputStream inputStream = new FileInputStream(Filepath);
     XSSFWorkbook wb_template = new XSSFWorkbook(inputStream);
     inputStream.close();

     SXSSFWorkbook wb = new SXSSFWorkbook(wb_template); 
     wb.setCompressTempFiles(true);

     SXSSFSheet sh = (SXSSFSheet) wb.getSheet(Sheet);
     sh.setRandomAccessWindowSize(100);
     
     lock_Final=(XSSFCellStyle) wb.createCellStyle();
     lock_Final.setAlignment(HorizontalAlignment.LEFT);
     XSSFFont font= (XSSFFont) wb.createFont();
     font.setFontHeightInPoints((short)10);
     font.setFontName("Verdana");
     font.setColor(IndexedColors.BLACK.getIndex());
     font.setBold(true);
     font.setItalic(false);
     lock_Final.setFont(font);
     lock_Final.setBorderTop(BorderStyle.MEDIUM);
     lock_Final.setBorderRight(BorderStyle.MEDIUM);
     lock_Final.setBorderBottom(BorderStyle.MEDIUM);
     lock_Final.setBorderLeft(BorderStyle.MEDIUM);
     
     int row_count=0;
     
             row_final = sh.createRow(row_count);
        
             cell_value("Type",0);
             cell_value("Column",1);
             cell_value("Result",2);
        	 
        	 
        	 
        	 row_count++;
        	 row_final = sh.createRow(row_count);
        	 if(Count_Mismatch_Flag) {
        		 cell_value("Count_Validation",0);
	             cell_value("NA",1);
	             cell_value("Fail",2);
        		 
        	 }
        	
        	 else {
        		 
        		 cell_value("Count_Validation",0);
	             cell_value("NA",1);
	             cell_value("Pass",2);
        		 
        	 }


        	 row_count++;

        	 row_final = sh.createRow(row_count);
        	 if(Source_Missing_Flag) {
        		 cell_value("Source_Missing_Validation",0);
	             cell_value("NA",1);
	             cell_value("Fail",2);
        		 
        	 }
        	
        	 else {
        		 
        		 cell_value("Source_Missing_Validation",0);
	             cell_value("NA",1);
	             cell_value("Pass",2);
        		 
        	 }
        	 
        	 row_count++;
        	 
        	 row_final = sh.createRow(row_count);
        	 if(Target_Missing_Flag) {
        		 cell_value("Target_Missing_Validation",0);
	             cell_value("NA",1);
	             cell_value("Fail",2);
        		 
        	 }
        	
        	 else {
        		 
        		 cell_value("Target_Missing_Validation",0);
	             cell_value("NA",1);
	             cell_value("Pass",2);
        		 
        	 }
        	 
        	 row_count++;
        	 
        	 row_final= sh.createRow(row_count);
        	
        	 if(Source_Duplicate_Flag) {
        		 cell_value("Source_Duplicate_Validation",0);
	             cell_value("NA",1);
	             cell_value("Fail",2);
        		 
        	 }
        	
        	 else {
        		 
        		 cell_value("Source_Duplicate_Validation",0);
	             cell_value("NA",1);
	             cell_value("Pass",2);
        		 
        	 }
        	 
        	 row_count++;
        	 
        	 row_final= sh.createRow(row_count);
	        	
        	 if(Target_Duplicate_Flag) {
        		 cell_value("Target_Duplicate_Validation",0);
	             cell_value("NA",1);
	             cell_value("Fail",2);
        		 
        	 }
        	
        	 else {
        		 
        		 cell_value("Target_Duplicate_Validation",0);
	             cell_value("NA",1);
	             cell_value("Pass",2);
        		 
        	 }
        	 
        	
        	 
        	
        	 for(int i=1;i<=Column_Mismatch.size();i++){
        		 row_count++;
        		 row_final = sh.createRow(row_count);
        		 cell_value("Data_Validation",0);
	             cell_value(Table_column.get(i),1);
	             if(Column_Mismatch.get(i)>0){
	            	 cell_value("Fail",2);
	    		}
	    		else{
	    			 cell_value("Pass",2);
	    		}
	    		
	             
        		}
        	 
        	
        	 
	        	
        	 for(int i=1;i<=Table_column_key.size();i++){
        		 row_count++;
        		 row_final = sh.createRow(row_count);
        		 cell_value("Data_Validation",0);
	             cell_value(Table_column_key.get(i),1);
	             if(Target_Missing_Flag || Source_Missing_Flag ){
	            	 cell_value("Fail",2);
	    		}
	    		else{
	    			 cell_value("Pass",2);
	    		}
	    		  
	             
        		}
        	 


 FileOutputStream out = new FileOutputStream(Filepath);
 wb.write(out);
 out.close();
}



public  void cell_value(String val,int cell) {
   
   cell_final=row_final.createCell(cell); 
   cell_final.setCellValue(val);
   cell_final.setCellStyle(lock_Final);
	
   
}




 
 
 



 
 


}

